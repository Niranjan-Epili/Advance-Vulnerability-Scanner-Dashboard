import streamlit as st
import os
import requests
import socket
import ssl
from urllib.parse import urlparse
import base64
import whois
from cryptography import x509
from cryptography.hazmat.backends import default_backend
import dns.resolver
import time
import pandas as pd
from io import BytesIO
from dotenv import load_dotenv

# Load environment variables from the .env file
load_dotenv()

# Access the API key
api_key = os.getenv("VIRUSTOTAL_API_KEY")

if api_key is None:
    raise ValueError("API key not found. Please set the VIRUSTOTAL_API_KEY environment variable.")

VIRUSTOTAL_URL = 'https://www.virustotal.com/api/v3/urls'
VIRUSTOTAL_FILE_URL = 'https://www.virustotal.com/api/v3/files'

# Define functions

def check_http_headers(url):
    try:
        response = requests.get(url)
        return dict(response.headers)
    except Exception as e:
        return {"ERROR": {"message": str(e)}}

def check_https(url):
    return url.startswith("https://")

def scan_ports(hostname):
    open_ports = []
    for port in range(1, 1025):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(1)
        result = sock.connect_ex((hostname, port))
        if result == 0:
            open_ports.append(port)
        sock.close()
    return open_ports

def check_malware(url):
    headers = {
        'x-apikey': api_key
    }
    url_id = base64.urlsafe_b64encode(url.encode()).decode().strip("=")
    response = requests.get(f"{VIRUSTOTAL_URL}/{url_id}", headers=headers)
    result = response.json()
    if 'data' in result:
        attributes = result['data']['attributes']
        last_analysis_stats = attributes['last_analysis_stats']
        return last_analysis_stats
    else:
        return {"ERROR": {"message": response.json().get('error', 'Unknown error')}}

def get_ssl_cert_details(hostname):
    try:
        cert = ssl.get_server_certificate((hostname, 443))
        return cert
    except Exception as e:
        return {"ERROR": {"message": str(e)}}

def get_ssl_cert_expiry_date(cert):
    try:
        cert_obj = x509.load_pem_x509_certificate(cert.encode(), default_backend())
        return cert_obj.not_valid_after
    except Exception as e:
        return {"ERROR": {"message": str(e)}}

def analyze_security_headers(headers):
    security_headers = {
        "Content-Security-Policy": headers.get("Content-Security-Policy", "Not Present"),
        "Strict-Transport-Security": headers.get("Strict-Transport-Security", "Not Present"),
        "X-Content-Type-Options": headers.get("X-Content-Type-Options", "Not Present"),
        "X-Frame-Options": headers.get("X-Frame-Options", "Not Present"),
        "X-XSS-Protection": headers.get("X-XSS-Protection", "Not Present")
    }
    return security_headers

def extract_url_details(url):
    parsed_url = urlparse(url)
    details = {
        "Scheme": parsed_url.scheme,
        "Netloc": parsed_url.netloc,
        "Path": parsed_url.path,
        "Params": parsed_url.params,
        "Query": parsed_url.query,
        "Fragment": parsed_url.fragment
    }
    return details

def get_whois_info(domain):
    try:
        domain_info = whois.whois(domain)
        return domain_info
    except Exception as e:
        return {"ERROR": {"message": str(e)}}

def check_url_length(url):
    length = len(url)
    return "URL length is acceptable." if length <= 2083 else "URL length is potentially too long."

def check_content_type(url):
    try:
        response = requests.get(url)
        content_type = response.headers.get('Content-Type', 'Not Found')
        return content_type
    except Exception as e:
        return {"ERROR": {"message": str(e)}}

def measure_response_time(url):
    try:
        start_time = time.time()
        response = requests.get(url)
        response_time = time.time() - start_time
        return response_time
    except Exception as e:
        return {"ERROR": {"message": str(e)}}

def get_dns_records(domain):
    try:
        records = dns.resolver.resolve(domain, 'A')
        return [record.address for record in records]
    except Exception as e:
        return {"ERROR": {"message": str(e)}}

def check_social_media_presence(domain):
    # Placeholder function: This would need to be implemented with actual checks
    return {"Facebook": "Not Checked", "Twitter": "Not Checked", "LinkedIn": "Not Checked"}

def scan_file(file):
    headers = {
        'x-apikey': api_key
    }
    files = {'file': file}
    response = requests.post(VIRUSTOTAL_FILE_URL, headers=headers, files=files)
    result = response.json()
    if 'data' in result:
        analysis_id = result['data']['id']
        return check_file_analysis(analysis_id)
    else:
        return {"ERROR": {"message": result.get('error', 'Unknown error')}}

def check_file_analysis(analysis_id):
    headers = {
        'x-apikey': api_key
    }
    response = requests.get(f"https://www.virustotal.com/api/v3/analyses/{analysis_id}", headers=headers)
    result = response.json()
    if 'data' in result:
        attributes = result['data']['attributes']
        return attributes
    else:
        return {"ERROR": {"message": result.get('error', 'Unknown error')}}

def create_report(results):
    buffer = BytesIO()
    with pd.ExcelWriter(buffer, engine='xlsxwriter') as writer:
        for sheet_name, data in results.items():
            pd.DataFrame([data]).to_excel(writer, sheet_name=sheet_name, index=False)
    buffer.seek(0)
    return buffer

# Streamlit interface
st.title("Advanced Vulnerability Scanner")

url = st.text_input("Enter URL to scan:")
uploaded_file = st.file_uploader("Upload a file for scanning:", type=['pdf', 'doc', 'docx', 'txt'])

if st.button("Scan"):
    if url:
        st.write("Scanning URL...")
        
        # Extract URL Details
        url_details = extract_url_details(url)
        st.subheader("URL Details")
        st.json(url_details)
        
        # URL Length Check
        url_length_status = check_url_length(url)
        st.write(f"**URL Length Status:** {url_length_status}")
        
        # Check HTTPS
        is_https = check_https(url)
        st.write(f"**Uses HTTPS:** {is_https}")
        
        # Check HTTP Headers
        headers = check_http_headers(url)
        st.subheader("HTTP Headers")
        if isinstance(headers, dict):
            st.write(headers)
            security_headers = analyze_security_headers(headers)
            st.subheader("Security Header Analysis")
            st.json(security_headers)
        else:
            st.write(headers)
        
        # Check Content-Type
        content_type = check_content_type(url)
        st.subheader("Content-Type Analysis")
        st.write(f"**Content-Type:** {content_type}")
        
        # Measure Response Time
        response_time = measure_response_time(url)
        st.subheader("Response Time")
        if isinstance(response_time, float):
            st.write(f"**Response Time:** {response_time:.2f} seconds")
        else:
            st.write(response_time)
        
        # Check for Malware
        malware_status = check_malware(url)
        st.subheader("Malware Status")
        st.json(malware_status)
        
        # SSL/TLS Certificate Details
        hostname = url.split("//")[-1].split("/")[0]
        ssl_cert = get_ssl_cert_details(hostname)
        if "ERROR" in ssl_cert:
            st.subheader("SSL/TLS Certificate Details")
            st.write(ssl_cert)
        else:
            st.subheader("SSL/TLS Certificate Details")
            st.text(ssl_cert)
            expiry_date = get_ssl_cert_expiry_date(ssl_cert)
            st.write(f"**Certificate Expiry Date:** {expiry_date}")
        
        # Scan Ports
        open_ports = scan_ports(hostname)
        st.subheader("Open Ports")
        if open_ports:
            st.write(f"Open Ports: {open_ports}")
        else:
            st.write("No open ports found.")
        
        # WHOIS Information
        whois_info = get_whois_info(hostname)
        st.subheader("WHOIS Information")
        if "ERROR" in whois_info:
            st.write(whois_info)
        else:
            st.write(whois_info)
        
        # DNS Records
        dns_records = get_dns_records(hostname)
        st.subheader("DNS Records")
        if isinstance(dns_records, list):
            st.write(f"**DNS Records:** {dns_records}")
        else:
            st.write(dns_records)
        
        # Social Media Presence
        social_media_presence = check_social_media_presence(hostname)
        st.subheader("Social Media Presence")
        st.json(social_media_presence)
        
        # Generate Report
        results = {
            "URL Details": url_details,
            "URL Length Status": {"URL Length Status": url_length_status},
            "HTTPS Check": {"Uses HTTPS": is_https},
            "HTTP Headers": headers,
            "Security Header Analysis": security_headers,
            "Content-Type Analysis": {"Content-Type": content_type},
            "Response Time": {"Response Time": response_time},
            "Malware Status": malware_status,
            "SSL/TLS Certificate Details": {"Certificate": ssl_cert, "Expiry Date": expiry_date},
            "Open Ports": {"Open Ports": open_ports},
            "WHOIS Information": whois_info,
            "DNS Records": {"DNS Records": dns_records},
            "Social Media Presence": social_media_presence
        }
        
        report = create_report(results)
        st.download_button(label="Download Report", data=report, file_name="vulnerability_report.xlsx")
    
    if uploaded_file:
        st.write("Scanning file...")
        file_analysis = scan_file(uploaded_file)
        st.subheader("File Analysis Results")
        st.json(file_analysis)
